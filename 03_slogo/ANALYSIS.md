CompSci 308: SLogo Analysis
===================

> This is the link to the assignment: [SLogo](http://www.cs.duke.edu/courses/compsci308/current/assign/03_slogo/)

Design Review
=======

-   **Overall Design**  
    Reflect on the coding details of the _entire_ project by reading over _all_ the code.
    -   Describe the overall design of the complete program:
        -   What is the high level design of _each_ part (front and back end) and how do they work together (i.e., what behavior, data, or resources each part depends on from the others).
        -   > Front end consists of the Slogo window, which contains multiple smaller sub-windows to represent different aspects of the view. The sub-windows, namely Console, History, Variables, Turtles, Toolbar, and the TurtleView are all grouped together under the bigger, general umbrella of "Slogoview". Each part's necessary data is provided by the Slogoview, which is passed the data from the "Main". Main is not aware of all the sub-windows; as per good design, the only open part of front end is the Slogoview, the rest is hidden and encapsulated. This way, because each subwindow only needs to be aware of some of the data, the delegation of that data is left up to Slogoview, thus demonstrating good design.
        -   > Back end consists of a data pipeline, with the components being a Factory to produce nodes (Command Factory), Node Builder (Works with Command Factory), Command nodes, Tree Builder, and Tree Evaluator. The logical flow of data was similarly in that order. From a high level, the backend is easily encapsulated, though due to time constraints/other concerns it was not done (I encapsulated the backend within main in the masterpiece as a sort of add-on). Each part depends on the data from the previous part because, for example, the data must be turned from string[] -1> command[] -2> tree -3> double. In this example, conversion 2 depends on the operation of conversion 1, and conversion 3 upon conversion 2. This interdepency can be hidden from the rest of the program with the previously mentioned encapsulation. The "Main" class currently handles the simulation itself and the data flow and management, so in a sense everything is already well encapsulated. 
        -   What is needed to add one of the following (include all the parts of the code or resources that need to be changed):
            -   new command to the language,
            -   > This is relatively easy. Assuming no special formatting (i.e. 4 lists, constants defined with a +, etc.), simply create a new command node within one of the preexisting packages (Movement, VarOps, etc). It's very plug-and-play; however, any deeper level changes that the command would make that would require data access beyond turtle/variables/functions would require the method signature to be changed for every command node to accomodate the new data. In addition, one line must be added to each of the language files to represent the translation of user input to command name.
            -   new component to the front end,
            -   > This is also relatively easy. Apart from scaling problems (it requires some math to figure out where to put a new window), adding a new part to the front end is just creating a new sub-window or object to add to SlogoView. This also assumes no new data is needed; if that new addition requires any new data, conflict occurs because currently that data isn't passed to SlogoView. As a result, changes to the method signature that is called within Main, as well as the data structure itself, must be added to Main.
            -   feature from the specification that was not implemented
            -   > Commands referencing changing pen color/background/image were built in the back end in that they exist as command nodes, but trouble appears when we move to actually changing the colors. Because each command node operates on the Turtle by calling public methods native to turtle, those methods need to be implemented in such a way as to actually do the operation. These methods were written, but it was Jamie's job to connect them to the front end so that visually things would change and to really flesh out that connection. That was not done, but cementing that connection would be an easy remedy and would allow all faucets of this feature to be implemented.
        -   Are the dependencies between the parts clear and easy to find (e.g., public methods and parameters) or do they exist through "back channels" (e.g., static calls, order of method call, sub-class type requirements)?
        -   > Inter-dependencies are very clear and easy to find because, for the most part (coding got sloppy towards the end), public methods are relatively rare, with only a large quantity existing in the Turtle class (naturally, to set position and things of that nature). Everything else is relatively straightforward; access is properly limited. There aren't static calls, and the hierarchy between Abstract Command Node and each individual one is clear. If a Command Node needs a "side effect" on the turtle, then it has a private method that will handle that aspect of the command's execution. Because each Command Node has it's own side effect, and in the interest of good design, the helper methods of each Command Node must be made private, with only one public method (getExecute) in order to execute the command. 
    -   Read over and describe two _components_ that you did _not_ implement:
        -   What makes it readable or not (i.e., do classes and methods do what you expect and have logic that is clear and easy to follow)? Give specific examples.
        -   > I did not initially build the Tree Builder, but I helped Liam brainstorm and design it, and a lot of debugging with it. What made it readable is that methods were very well named; it was clear what each helper method was intended to do and the conditions upon which it was called were easily comprehensible. For example, helper methods including "handleElseIf" and "handleIf" were written by me, but their structure was very similar to the way Liam's "handleDoTimes" was designed. The biggest challenge in developing within Tree Builder was that the global counter (to see where in the array we currently were) was accessed all over the place, to the point where, during testing, the first "fix" was always to delete the incrementation once and see what happens. To this end, however, I'm not entirely sure how to refactor it so that it would be easier to keep track of when/where in the array we currently are. The only solution I can think of is to standardize where/when we can call the incrementation, which, while not difficult, would be quite annoying.
        -   > I also did not build the Command Factory/Node Builder classes, though I did show Ryan how to build these classes. What made this class readable is the extremely clear data flow. In other words, the sort of visualization of what the classes were doing and how they worked together helped a lot. For example, because the Command Factory calls the Node Builder, and the Command Factory is responsible taking an array of strings and coverting them into an array of nodes, the Command factory simply makes multiple successive calls to Node Builder, which returns a single node. There's not much here to go wrong, and once the factory was done, not much left to build.
        -   What makes it encapsulated or not (i.e., can the implementation be easily changed without affecting the rest of the program)? Give specific examples.
        -   > The Tree Builder is encapsulated in that, publically, only one method is available. Therefore, all the inner workings of the tree builder are hidden and independent of where it is called. Should we want to change the implementation of Tree Builder (necessary if new formats are developed or unique node types), it would be quite simple. As long as the publically facing method is still present, and that Tree Builder can take in an array of Nodes and output a tree, there would be no problem.
        -   > Similarily, with the Command Factory, the implementation of this can be easily changed without affecting the rest of the program because, again, as long as the publically facing method is still present, and that Command Factory can take in an array of Strings and output an array of Nodes, there would be no problem. It's not necessary to use the Command Factory-Node Builder architecture that we implemented; any implementation is plug-and-play as a result of our data flow
        -   What have you learned about design (either good or bad) by reading your team mates' code?
        -   > Something bad that I learned here was that, while tree-building is necessarily complex, often times incrementation can be extremely difficult. While coding, it might make a lot of sense to the coder, but to an outside eye it may be significantly more complicated. To remedy this, perhaps  standardizing when/where incrementation happens with a call to a helper method might clean things up. It helps with readability and logical flow, though in my opinion tree building is a complex system that, at the end of the day, will have significant difficulty maintaining readability.
        -   > Something bad about the command factory is the usage of the sort of nested try catches. In other words, when searching for classes to create, because different command nodes exist in different packages, the node builder must try the first package, catch an error, try the second package, catch an error, try the third package, etc. While I'm not sure if this is bad design or good design, it felt necessary even though, to me, it felt very unclean and inelegant.
    -   Is the total code generally consistent in its layout, naming conventions and descriptiveness, and style? Give specific examples for or against by comparing code from different team members.
    -   > The code is somewhat consistent in it's layout and naming conventions. While I would personally rate our naming conventions a 8/10, occasionally each person has made some sort of lapse in judgement. For example, on my end I had two methods within each Command Node called getValue and getExecute, both of which should usually return the same number. There was a sort of unnecessary logical separation between getExecute (returns value and moves turtle) and getValue (computes the return value by calling the getExecute of the children) but that significance sometimes can get overwritten. Similarily, within tree building there are several counters to keep track of where we are in terms of tree building, and when the names are similar to "buildcounter", some significance and readability is lost. Within the Turtle class as well, many of the methods called by the command nodes are named well alone, but in conjunction with each other may cause some confusion. This is sort of a result of, at least in my experience, laziness and the view that the programmer understands the difference, with little regard to improving readability. 
-   **Your Design**  
    Reflect on the coding details of _your_ part of the project.  
    

-   Describe how _your_ code is designed at a high level (focus on how the classes relate to each other through behavior (methods) rather than their state (instance variables)).
-   > My code revolves around the Command Node hierarchy. Essentially, from a high level, every command node will have some number of children nodes, depending on the type (sum has 2, fd has 1, etc), with every child node also having children until a "constant" node is reached. The tree builder is responsible for determining which children nodes are connected to which parent nodes, and the fact that a node is most often simultaneously a child and a parent requires that every node be able to return a double. Effectively, the only relationship between nodes is that the value of the parent depends on the value of the children, and in obtaining that value, the internal processes of the child execute, which, if there are more children, call the internal processes of the grandchildren, and so on. To do each of these calls, a parent would call child.getExecute, which would return the value of the child and execute the intermediate steps.
-   Describe two _features_ that you implemented in detail — one that you feel is good and one that you feel could be improved:
    -   Justify why the code is designed the way it is or what issues you wrestled with that made the design challenging.
    -   Are there any assumptions or dependencies from this code that impact the overall design of the program? If not, how did you hide or remove them?
    -   > I feel like my inheritance hierarchy is as good as it gets. Because any combination of command nodes may be strung together, that fact naturally lends itself towards using only references to methods that every node will share. Otherwise, for example, if Node A requests a method Z that only exists for Node K but the child of Node A is Node C, then there is an inherent and major conflict there. By making the reference between all nodes the same uniform method (getExecute), any nodes can be linked to each other, provided that children are enabled for that particular node. One assumption that this makes, however, is that there will be no "special" nodes, nodes that require more than the singular method. In addition, a bigger assumption is regarding data; every node has access to the same data set, as a result of every node having the same method signatures. Even if unused, the data access is there. Changing the data access (adding to it usually) of one Command Node requires that every command node be updated to reflect this change. This impacted the overall program in that updating code to account for multiple turtles was a major pain; every method signature had to be updated and every method updated to reflect the changes (i.e, to execute only on "active" turtles). 
    -   >This ties into the second feature that I thought was poorly done: defining the environment. Every node gets passed a map of variables, functions, and turtles. Initially however, the turtles were not passed. Changing this, as already noted, was a major pain. In addition, trying to add a map of colors and a map of images proved to be too time consuming, though not impossible. The workaround solution I came up with was to store that data within the turtle itself. While that breaks a lot of rules of OOP, it made it easier in terms of not needed to update signatures. An improvement is to perhaps bundle all of that data into some sort of data structure and only pass in that data structure. This would allow for the creation of new data/parameters in only a single place and passing it in a single place. No method signatures would need to change, and no additional error checking would be necessary.

-   **Flexibility**  
    Reflect on what makes a design flexible and extensible.
    -   Describe what _you_ think makes this project's design flexible or not (i.e., able to support adding similar features easily).
    -   > I believe our design to be flexible most clearly in the addition of new commands; a new command is simply the addition of a command node into one of the packages and the changing of the language resource file to reflect the new command. Additional flexibility lies in the ability to chain long lines of command nodes together and having no special code to handle specific interactions. Using this design, any line of commands can be properly taken in and interpreted. This power also stems from the presence and usage of the factory method and reflection; no code needs to be changed anywhere to accomodate. 
    -   Describe two _features_ from the assignment specification that you did _not_ implement in detail (these can overlap the previous ones but must be discussed from this _different_ perspective):
        -   What is interesting about this code (why did you choose it)?
        -   > Additional Environmental Commands:
            > This code is interesting in that it requires the backend to be able to control and manipulate the front end without simply manipulating the turtle. In other words, up to this point all manipulations are either purely mathematical (i.e. no change in the front end) or graphical (i.e. moving the turtle around, rotating, etc). With the implementation of Environmental commands (like change background) there is a new faucet of change and control; there's more to pass back and forth. For example, turtle level changes can all be done within the turtle itself because the location of the turtle is saved within the turtle. However, the backend has no idea what the front end is; it does not even know that the turtle necessarily has a position. By editing the parameters of the turtle the backend indirectly changes the front end. A new vehicle of data transfer for non-turtle data would be needed. 
        -   > Undo last command:
            > This code presents an interesting challenge in that there are a wide variety of ways to implement this feature, each with it's own drawbacks. For example, if the only objective is to be able to "undo" once, then a simple solution is to always have two sets of data avaliable. This solution is the least analytical and simplest to implement; however, again only one step back is possible. If two steps back are needed, then three sets of data are necessary, and so forth. A cleaner and better solution that scales infinitely is much harder to come by, as within a command there are operations that are not just simply solvable by changing the values to negative; sometimes a command might have a variable definition within it, and undo would need to restore the old value. Even beyond that, a chain of commands would have a lot of problems inherent to the fact that logically its hard to figure out whether the undo executes on the "old" variable or "new" variables, and that the order of execution matters significantly. If "undo" only referred to visual and graphical undos, this feature is quite easy. 
        -   What classes or resources are required to implement this feature?
        -   > As previously mentioned, some classes and resources needed are primarily changes to the method signature of the command nodes to pass in more data structures. No new classes, aside from command node classes, are needed to adapt to this change. In addition, within the "update" operation of the observers and observables, there needs to be access to the new data structures in order to change whatever the command asks upon execution. Essentially, because "background" and "pen" aren't objects, the data that they would normally contain need to be passed along some how, and then reaccessed by the front end to visualize them. 
        -   > As previously mentioned, the simplest solution would be to just add a data structure within the "Main" class that would save the "n steps ago" state of the entire simulation and the objects within it, sort of like a screenshot. Undo-ing would then simply be restoring this old screenshot. This solution works because it truly and completely does undo the last action taken by the user. This is limiting, however, because it then must store two copies (one step ago, two steps ago) for two undoes, and so on. To make it scale infinitely back, the number of copies would have to equal the number of instructions the user has inputted. This, while function, is the least elegant coding design I've ever thought of. 
        -   Describe the design of this feature in detail (what parts are closed? what implementation details are encapsulated? what assumptions are made? do they limit its flexibility?)
        -   > The implementation of the environmental commands maintains the exact same structure that is currently present. Nothing changes in terms of encapsulation, the only thing is that now more data is encapsualted in a new data structure that must be passed into every command node (to preserve uniformity across all command nodes since they're instances of an abstract class). No new assumptions need to be made, and the flexibility is the exact same as it was before. Adding new features is identical, though perhaps the argument can be made that it is even more flexible now that a wider variety of manipulations are possible. 
        -   > The implementation of the undo feature requires some minor changes within the command node structure. First, aside from the new data structure within Main, all data must be passed to every single command node. This seems inelegant but inevitable. Thus, if 10 copies exist, all the nodes now have access to the past 10 states. A special node will be designed, likely called "undo", who's getExecute simply iterates across the data structure passed in that represents the "current" state of everything, and replace it with the one before it, likely with a very large for loop. Ultimately, the only limitations on flexibility lie in the data being passed into the Command Nodes. 
        -   How extensible is the design of this feature (is it clear how to extend the code as designed? what kind of change might be hard given this design?)
        -   > Both features, as outlined, should be pretty easily to extend, given enough experience with data structures. For example, a smart decision would be to bundle all the data together so that method signatures will never have to change. This way, definitions only have to occur once and saving data occurs only once. The major challenges revolve around data management and how they would be passed to the command nodes. This becomes an entirely backend problem, and the backend design is flexible enough to deal with it.  
-   **Alternate Designs  
    **Reflect on alternate designs for the project based on your analysis of the current design or project discussions.
    -   Describe how well (or poorly) the original design handled the project's extensions to the original specifications and how these changes were discussed and decisions ultimately made.
    -   > Our design handled the extensions perfectly well for command extensions, except for the connection between turtle data and front end that was not built. All I needed to do was add new command nodes, and handle special cases. In other words, code needed to be added for the commands themselves, and for the tree builder to recognize that the new nodes needed a special list node. In addition, multi-turtle was also relatively easy. We needed to change the method signatures of all the command nodes to take in a data structure containing all live turtles. This proved to be a bit more complex in keeping track of turtles, but was not too difficult to implement, only tedious. Other extensions were significantly more difficult. For example, the current design does not support the multiple parameter operations (i.e. sum 10 10 10), and is incapable of supporting them without adding a new way to distinguish parenthesis. Once that is done, however, it should not be too difficult to implement, though it would also require some computational alterations within the individual operations classes.
    -   Describe two design decisions discussed by the team about _any_ part of the program in detail:
        -   What alternate designs were proposed?
        -   What are the trade-offs of all the design choices (describe the pros and cons of the different designs)?
        -   Which would you prefer and why (it does not have to be the one that is currently implemented)?
        -   > Using reflection within the factory was discussed between Ryan and I. Initially, due to time constraints, Ryan didn't think that we had the time to begin and understand how reflection worked in a factory. As a result, Ryan proposed simply hard-coding each possible command as a sort of "if" statement with a boolean expression (if (fd || forward)). However, we quickly realized the inflexibility and inelegance of that solution, and both agreed that reflection was  without a doubt a better design, despite the widespread internet hate it gets. This decision proved to be best, as later on very little changes needed to be made to the factory. It would adapt by itself.
        -   > Separating the front end from the back end using "Main" to manage data was a design decision. An alternative could have been to integrate the entire program into the front end. By using Main as the intermediary between the front end and the back end, we are able to make the pipeline even more plug-and-play, and really focus on that nature of the design. In addition, because all the data is stored inside the Main class, neither the front end nor back end actually "knows" what's in the environment. Rather, they operate on whatever is presented to them. This makes adding features such as saving current state relatively simple, as it is entirely contained within a single class. Integrating the management of the application into the front end is viable, but bad design because it prevents the logical separation between front end and back end, and the independence of each. In addition, it makes for rather complex code, as accessibility between back end and front end becomes complicated and convoluted. The manager class makes it much cleaner and more enjoyable and logical. 
-   **Conclusions**  
    Reflect on what you have learned about designing programs through this project, using _any_ code in the project as examples:  
    -   Describe the best feature of the project's current design and what did you learn from reading or implementing it?
    -   > I think the best feature was the tree design. While everything else is important and I'm proud of how I expressed inheritance in the Command Nodes, I think my initial argument towards using a tree and the node design was critical to our flexibility. I've already discussed this is detail elsewhere, but in essence the idea to use Command Nodes that all are extremely similar in API and which can recursively call each other and evaluate and execute each other makes for extremely easy command execution and chaining once individual commands are functional. I learned so much about the importance of really approaching the challenge one problem at a time; by simplifying our job to only making sure individual commands worked and eliminating chaining commands as part of the problem, the task became significantly less daunting and much more manageable. 
    -   Describe the worst feature that remains in the project's current design and what did you learn from reading or implementing it?
    -   > I think the worst feature in the current design is that each command node must be passed individual data structures. This isn't necessarily bad from an OOP perspective, but its less than ideal in terms of flexibility. In other words, because adding new data types and structures means the need to adequately edit every single command node, it makes far more sense to simply lump all the data together into some larger data structure (for example, a map of maps or an array of maps or the like). As a result of our design, and especially evident through the addition of multiple turtles, it became abundantly clear that the design was perfect assuming no data-level changes would occur. Throw that in there, however, and you had a recipe for disaster. 
    -   To be a better designer in the next project, what should you
        -   start doing differently
        -   > Discuss and plan a lot more, and a good rule of thumb is to restrict the inputs to any method as much as possible and to lump data as much as possible. I'm not sure if this is good design, and will talk to TA about it, but it seems much cleaner assuming uniformity across all platforms in terms of data access. 
        -   keep doing the same
        -   > Helping the team in terms of contributing to the overall project, and more importantly continue checkups on progress.
        -   stop doing
        -   > Keep pushing ahead while other parts of project lag behind, and build parts of the project based on "person X should be building Y in Z way"