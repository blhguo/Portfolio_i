CompSci 308: Cell Society Analysis
===================

> This is the link to the assignment: [Cell Society](http://www.cs.duke.edu/courses/compsci308/current/assign/02_cellsociety/)


Design Review
=======

### Overall Design

* An advantage to our design is the linear data flow. We set out to separate the XML reading, Cell behavior, Simulation presentation, and user interaction as much as possibe. This modularity is an advantage because adding features then becomes less of an issue of integration and more of an issue of only implementing it. 
* Our code was essentially divided into four parts: XML Parsing, Cell interactions, Simulation graphics, and User interaction. A typical data flow would be as follows:
> - The user is presented with the Start menu. This menu is simply a series of buttons that allow the user to select a simulation, load a file from memory, create their own file, and launch the simulation. After the user decides on a course of action, the button clicked calls the XML reader. The specific XML reader depends on what kind of simulation is being run, something specified by the User at the launch screen using a drop-down menu. Each type of simulation needs a unique XML reader because the information taken from each XML file differs. For example, a "Wator World" XML reader has little use for constants such as "probGrow" and "probCatch", while having a critical need for Shark Gained Energy levels. Some refactoring here is possible due to the fact that many aspects of the simulations are consistent throughout (e.g. cell size, grid width, etc), but was not necessary in producing a functional product, which was our primary priority. 
> - The XML reader interprets the file given and, according to the simulation type specified, loads the corresponding simulation and then initializes the Grid object. The Grid object contains vital information such as size and cell count. Grid also contains a method to generate the next "frame" of the simulation by building a new Grid object based on the current Grid object. In doing so, it calls methods on each cell in order to compute the cell's next state (each cell only manages it's own state and not that of those around it) In essence, the Grid object iterates through every cell it stores and calls cell.nextState(), which returns the next state of the cell based on it's surrounding neighbors and the probabilities defined by the XML file. Grid then adds that new cell to it's respective position in a new Grid object. The XML parser helps define the global variables such as cell size and grid width, values useful to scaling the simulation to fit the screen. 
A significant but mundane challenge present is the computation of proper cell placement; because "hexagon" and "triangle" are not regular shapes in the way that "rectangle" is, it becomes necessary to compute and manually add the coordinates of each vertex to the points of a polygon. This can become difficult when considering the irregularity of a triangular or hexagonal array; coordinate equations depend on even or odd rows, and even or odd column. Each respective entry in the switch case represents one shape, with the inputs being a cell object, position, and dimensions. These inputs may require some scaling to ensure that the simulation does not exceed the boundaries defined by the inputs to the scene returned by setupScene. This scaling is handled, albeit with some addition of global constants. 
By calling Cell.getDisplayColor, the individual shape generation methods know what color to fill each cell with, and, with the implementation of an "if (cell instanceof AgentCell)" statement, we can exclusively mark Agent cells regardless of simulation type (although no marks will be made unless the simulation is SugarSim, since the Agent Cell class is never used outside of this simulation). An alternative implementation that would have eliminated direct cell-manager interaction would have been to pass in Grid.getVisuals, which is a 2D array of colors. This is a simple edit that represents a step towards Object oriented programming., however minor.
> - The Manager also is responsible for parameter variation and plotting data. To that end, it asks the Grid class to provide a map of strings to numerical values, with strings representing type of cell and the numerical value representing the count for that specific  cell type. It takes those data points and adds them to an XYChart.Series() object as data. The XYChart automatically updates, and the positioning of chart/sliders/simulation are scaled using VBoxes and buffer constants representing the height and width of objects. The sliders take in a range of values and the current value from another map from the Grid object, which maps Strings (representing parameter type) to an array of parameter minima, maxima, and current values. It does so using an abstract method inherent to the Grid class called "getCurrentParameters". One of the few parts of the backend that the Manager class can directly change and has access to is related to the sliders; should the user adjust the sliders, the current value of the slider and of the entry in the array mapped to by the map that represents the current value is permanently updated. This interaction is necessary in order to ensure that changes to parameters such as "probCatch" remain permanent. 

* Adding a new simulation
> Adding a new simulation is relatively easy. To begin, a new XMLReader specific to the new simulation would need to be developed and added, as well as a options updated in the menu scene and the Save Button calls. Without doing so, it is impossible to accurately select and generate a simulation due to the inherent and resultant ambiguity of the parameters. Then, extensions of the abstract Cell class must be made to accommodate the new simulation type, with instances representing each possible cell. New parameters and constants need to be defined, grid shape needs to be defined, and the specific cell-to-cell interactions need to be defined in order to successfully and accurately run a new simulation. In the midst of all that, the definition of neighbors needs to be updated: currently, only specific definitions of neighbors are available, see code for more details. For example, if an interaction is relative location dependent, then some level of abstraction within the definition of neighbors will become necessary. A minor but easily overlooked update is to change the Resources file to accommodate the new buttons/menu options, (doing so prevents the presence of hard-coded button titles) as well as the XML save button's specific method calls (needs a writer method to save the current state of the simulation). 
* Dependencies
> The dependencies are pretty clear. The variables and objects expected by each method and each class are aptly named, and, for the most part, the few methods that should be public are made publicly available, and Eclipse is able to suggest these methods for access. For example, the graphical interface is largely unable to impact the flow of the simulation; the only impact it can have is dynamic adjustment of interaction constants and parameters. A majority of the "behind the scenes" code is hidden from the visualizer and largely inaccessible. 
> One difficulty we ran into was that, during the initial testing phases, separating Graphical User Interface from the Manager class proved much more difficult than expected. The necessity to keep passing objects in and passing them back, the inaccessibility of other objects and the many issues regarding inheritance and global access and passing access made it cumbersome. In addition, after speaking with our mentors/UTAs, they argued that the effort was largely for naught; while separating the visualization from the manager is a good idea, it proved to be much more difficult than expected, with really little to no benefit. A sort of half-way implementation of this could be to create separate helper classes specifically handling scene creation, button creation, and graph creation. This design would make debugging each of these individual parts easier. Within the cell and the XML hierarchy, there are dependencies in that each specific implementation of cell is an extension of the abstract class cell (same with grid and xml), so there is the inherent inheritance and dependency on defined methods and inherited methods there. 
 

* Grid 
> - Grid was a class that essentially ordered and managed the arrangement of the cells. It kept track of each cell, it's location, and the overall shape of the simulation. Because there was an abstract Grid class, each simulation has it's own implementation of "grid" specific to it's functions and purposes. The Grid class was extremely easy to read and understand, mainly because I did not really have to worry about the mathematics and the management of cell updates and rather only had to be concerned with the methods that I could access, namely getCellArray. This fact is demonstrative of the power of Object-oriented programming; because I can only access a few options, coding changing and interactions becomes much simpler. Because getCellArray was implemented in the abstract class for grid, Yashas was able to easily add new simulations by simply creating new extensions of Grid, and I never had to worry about special interactions of cells with each other; as long as getCellArray did it's job and passed me a 2D array of cells, indexed with zero heading, then everything worked out as intended. This implementation was encapsulated in that every subclass call it made called upon abstract methods defined in the abstract Cell class; adding or changing interactions was a manner of changing details on the Cell-class level rather than a ripple effect up through the grid level. Because the Grid class acts like an organizer class and grouping class rather than as it's own separate entity, it is easily changed and is very adaptable.


* Cell
> - Another class that worked very well was the Cell class. The Cell class was responsible for computing it's next state, given a list of neighbors. This method, nextState, depends on a cumulative reaction to neighbors; in other words, the percentage of change in a cell must be dependent on the total number of neighbors; the current implementation does not account for relative locations to the cell. For example, it would not be currently possible to implement a system in which cells cardinal to the current-to-be-updated-cell have an increased chance of spreading fire. This is due to the nature of the list; no order or organization has been established, nor any way to interpret that order or organization. However, from the visualizer's perspective, the cell class could not have been better written; it's interactions with grid were flawless and the one direct call made, a call to getDisplayColor, was simple and easy to use. Similar to the Grid class, this class is well encapsulated because it only knows information about itself; changes to it's behavior can happen on a local level and do not affect the rest of the program, assuming that all the methods inside the abstract cell class are implemented with proper return values. 
> - I think, for the most part, our design and data flow was well done. Good design is design that can easily be updated and changed, and the breakup of data handling and encapsulation of methods really made it simple and easy to update and edit things in our code. For example, the addition of new shapes was difficult math-wise, but in terms of things that needed to be changed, all that we needed to update were the neighbors method and the shape that was to be drawn. Good code is characterized by flexibility and malleability more so than anything else, with a design that is robust enough to handle a wide variety of applications. 
 
* I believe our code to be relatively consistent in terms of data flow and design, with the majority of the project built in a "plug-and-play" manner. This is likely due to the fact that the project was built in pieces; in order for gui to work, for example, I needed to know what sort of objects I could expect from Grid, and more importantly when we needed a specific type of implementation or a specific parameter or object from another person, we communicated that fairly well. Naming conventions were well done; it is clear what classes are subclasses and what their intended use-cases are, (for example, if a class has the word "fire" in it at all, it is designed to work with the Fire simulation, and the cell types, grid types, xml reader and xml writer all reflect this design motive. This naming convention does not really extend to the visualizer class because the visualizer class can deal with any type of simulation and cell) and methods that should be accessible are made public, while those that should not be are made private (for example, Visualizer can call getCellArray from Grid (in order to convert the grid object to a cell array) but is unable to call setDisplayColor (because it should not be able to set the display color of the cell, only read it. In fact, for the most part the visualizer is unable to impact the backend of the code at all; most of the methods that the Visualizer has access to are effectively read-only. 
 

### Your Design

* From a high level, my code effectively makes calls to Grid.getCellArray and Grid.nextState in order to retrieve those two things. For the most part, my code (gui) does not interact with the rest of the code except to receive data. Data received centers mostly around getting the current state of the grid from the Grid class (in the form of a 2D cell array by the way of getCellArray), asking the Grid class to load the next state (thereby telling the Grid class to iterate throughout each of it's component cells and call nextState for each cell), getting cell color from each individual cell (this part can be easily refactored so that the color is retrieved from the Grid rather than the cell, thus completely separating visuals from cell, but currently Yashas implemented color as a parameter of cell), setting/changing parameters of the simulation (by passing the simulation back a map of strings to new parameter values as input through a slider), and passing the current state to the XML writer as part of the save function. In regards to saving the file, because the visual simulation handles rescaling every time it is passed in a new file to be read, the values of the cell size and grid size are saved and passed as their original values into the XML writer. When the file is reopened, the simulation rescales everything to fit the screen again. 
> The good feature
> - One feature that I am particularly proud of is the way shapes are handled. By using a switch case to decide which shape to generate (this is abstracted to a factory in the master piece, but probably in a less-than-optimal way), and because this shape generation is not dependent on the simulation type itself, it can be widely applied to any simulation. In addition, because the size of the shapes are scaled by scaling the inputs to the shape generation methods, implementing the "infinitely growing" simulation grid becomes much more of a backend implementation challenge than it is a front end design challenge. I'm particularly proud of this implementation because to me, it represents a robust way to solve a significant and daunting challenge, at least at first. This flexibility comes from the fact that the shape generation always takes in the same scaled inputs, regardless of simulation. Every single cell must have these values and the grid must always have getCellArray implemented. Because this feature takes in parameters that are guaranteed to be there irrespective of any other factors, and because these parameters are pre-scaled, the shape generation experience is overall smooth and robust. This code, of course, assumes that error checking has already been done (e.g, no cellwidth > gridwidth) and that the getCellArray method and all of it's inherent and preceding calls are valid. It does no error checking of its own, largely because, for the most part, there isn't much error checking left to do. In terms of dependencies generated, however, the difficulty arises in that this design inherently limited both the shape choices (must be a square, triangle, or hexagon, though no other shapes are capable of regularly and uniformly filling in a grid) and shape dimensions (there is no way to force a regular hexagon or an elongated hexagon; the implemented design forces the shape to be of a speficied proportion determined by the scaling. These limitations and assumptions, however, are relatively minor, and are hidden by nature of their rarity/difficulty to encounter. 
> 
> The bad feature
> - One feature I am not proud of is the implementation of buttons. While there was nothing inherently bad or wrong about the button design, the placement of all the buttons and their respective helper methods in the same, large manager class, as well as the somewhat unnecessary addition of some of the buttons contributed to the sheer size of the Manager class. It was designed this way not by intent, but moreso by "we should have a button that selects the type of simulation" and by "we should have a save map button. Because they were implemented one at a time with little forethought, they were effectively all tacked on to the Manager class, something that contributed to the convolution of Manager. One dependency that resulted, however, was that the methods called by the buttons on-click were present in the Manager class, and, with previous experience, extracting buttons became relatively difficult because other called methods needed to be extracted as well. This was a missed opportunity for potential inheritance hierarchy, and less cumbersom code in general.
 
### Flexibility

As noted before, I believe our code to be decently flexible. In my experience with Sprint 2, adding features was not very difficult. For example, incorporating different shapes was simply a matter of adding different shape generators, albeit with a lot more math and scaling challenges than I expected. Because a simple switch case decides to generate squares (if the simulation shape is a square), triangles (if the simulation shape is a triangle), or hexagon (if the simulation shape is a hexagon), adding new shapes was and is simply a matter of performing the math to convert a 2D regular square array into a 2D staggered (if necessary) alternative shape display. From a backend perspective, this simply required a new definition of neighbors, and for good measure we added all reasonably expected definitions of neighbors just in case and for future flexibility. Another feature that demonstrates our flexibility is the chart; because the chart simply takes in a map of strings to values, any number of lines can be plotted, scaled, and labeled without additional code or hard-coded values or quantities, as long as the method to retrieve such a map worked properly. Other features, including a "save" button and a "Q to quit, D to speed up 2x without caps, etc) were easy to implement because they were simple additions to scenes or to input handling. Even The sliders were well implemented; the number of sliders and what they control are automatically decided and adeptly labeled. Space is automatically scaled to fit them in as well. 

> - This code is interesting because it introduces a new level of complexity and interaction between the user and the simulation; while the manager class and the visuals, for the most part, do not interact with the other parts of the simulation other than calling for assistance with certain tasks, the dynamically changed cells requires the front end to both consider the data type that the backend would want to be passed and a method to prevent overloading the simulation or giving conflicting instructions. To the first point, for example, it seems most like that the Grid would want to be passed back a Grid to maintain the parallels of "grid in grid out" consistency between Grid and Visualizer. However, a more efficient and perhaps better way to design this is to only pass back the location (row, column) of the cell and what state it is being changed to. This saves space in terms of data transfer and operational complexity (Grid does not have to regenerate an entirely new grid and can replace only one cell), but presents the challenge that it now violates some aspects of OOP; because in order to implement this feature in the manner described, the visualizer would need to know and be able to set cell states arbitrarily. One workaround for this challenge is to instead pass back a color, and have the grid either interpret the color as a cell type or pass back to the cell to return a new cell type. In either case, many challenges need to be addressed. The second major hurdle, however, is one of computation; it is possible that the system, when calling "step()", might have two possible cells to work with. Essentially, the best way to design such a feature is to only have it work while the simulation is paused; if it were possible while the simulation was playing, it is too difficult to accurately change a single cell that you want to change. Timing becomes an issue, and it is impossible to revert back a step in terms of simulation progress. A deep level change between the Manager class and the Grid and Cell subclasses needs to be made in order to allow the manager to set and dynamically alter the simulation. There are no flexibility implications, however. This feature is extensible in that it allows for greater user control of the simulation; with this design implemented, it is possible to allow to the user to completely control the simulation and guide it in whatever direction he/she wants. While the user can already do this (by manner of custom simulations), it is a different thing entirely to design the simulation as to allow this change to happen while the simulation is currently running. 

Another feature I did not implement was the multiple windows of simulations. 

> - This feature is interesting because it allows for the user to compare multiple "playouts" of the same simulation, and even beyond that multiple "playouts" of the very similar simulations. For example, if I as the user wanted to compare the effects of starting the fire at the center of the forest surrounded by trees as opposed to away from the center with a higher scarcity of trees, they, using this feature, would be able to. In order to implement this feature, however, the Manager class must undergo significant changes in order to store multiple instances of grid and multiple instances of every variable. A natural extension of this "duplicate" button is simply a multiple simulation button; the ability to load and run two simulations concurrently. This brings up interesting challenges related to the user interactions. For example, should the keyboard-bound controls affect both simulations or only one simulation? Beyond that, this feature opens the door to many more features, for example, a button could be designed to sync the two simulations by keep track of step count. Because the graphs and the sliders for each simulation are tied to the grid's simulation and in the same window, creating new simulations in new windows would not have to really deal with this conflict. Because this code is a new addition to the simulation, one challenge that might be difficult to work around would be trying to extend the new windows to work simultaneously. Though the step-syncing method is useful, there would not be a way to play both simulations at the same time.

### Alternate Designs

Some alternative designs were mainly centered around changing the Grid rather than building a new Grid. However, this design presented the challenge of what I believe Professor Duvall referred to as the ripple effect: a change in cell (1, 3) would impact it's surrounding cells within the same time-step in an unintended manner. That unintended effect would spread in such a way as to throw off the entire simulation. Initially, our solution was to mitigate this effect my having each cell save the current state and the next state, and when the new grid was visualized, the cells would replace the current state with the next state. We ultimately decided against this design because it was more intuitive and better to simply build a new Grid for each frame. This design had no trouble adjusting to the new specification additions presented, mainly due to the fact that the core of the assignment had not changed, only additional new features were added. 

A second design choice we made was to have each cell be responsible for updating itself and only itself. Because each cell's data and next state are saved within only the cell, the simulation has better data flow and control. In addition, it was more intuitive and simpler to have each cell behave according to it's surrounding cells rather than each cell change it's surrounding cells. Doing the later would require us to keep track of which cells had already been changed, how we want to change the surrounding cells, how do we compute the surrounding cells, and how we can tell when we are done. An minor advantage would be iterating through fewer cells and calling update fewer times, though efficiency is not much of a concern for us. As a result, we opted instead to generate a new Grid for every frame of the animation. This design choice also proved effective in the long run; the new specifications required updates to the neighbors method, and having to implement new methods to change each of the surrounding neighbors would have been quite difficult. Instead, having each cell be responsible for it's own state and it's own nextState proved to be a good design choice overall.

Another design choice we made and reverted was to separate visuals from manager entirely. Though we made it quite far down that path in Sprint 1, the number of cumbersome errors related to variable accessibility and return values, in addition to advice from mentors cautioning against this implementation, ultimately caused us to abandon that addition and integrate all visuals into the Manager class. The one major drawback to this design was that the Manager class now ended up quite long; because every visual object exists inside the manager class, including their setup methods, the manager class became quite heavy and burdened, with work not quite as well distributed. 

### Conclusions

* The best feature of this project is likely the implementation of inheritance through the Cell-Grid interaction. Reading through that code demonstrates how much of a shining example it is to the power of inheritance. Every subclass is built simply and clearly, with new changes and edit being simple to make. Entire simulations can be easily added and old ones edited, with the addition of new cell types easy. The extensions of each specific grid type to math the given simulation was also very well done, as well as the interplay between the backend and the visualization. In contrast, the worst feature is likely the existence of repetitive code; due to the fact that each XML file parser needed to parse for different parameters and values, there is a lot of repetitive code that Marcus wrote in order to accommodate for the different types of simulations that needed to be set up. Learning from that, I think a greater amount of time and energy could be committed to simplifying code and refactoring; due to poor time management and conflicts with other classes (we all had pretty bad weeks during this project) a lot of code was done last minute and not in the cleanest way possible. 
* In order to be a better designer in the next project, I should 
 > - Start requesting more information from my team mates, i.e knowing exactly what I was expected to do and what I would be passed to do it. 
 > - Start projects earlier and finish features before moving on to the next feature
 > - Start asking for more help when I need it; I often find myself struggling and sort of "bashing the code until it works", frequently late at night
 > - Start working on different parts of projects or of the same file so as to try to avoid merge conflicts as much as possible
 > - Keep looking for ways to improve data flow and code design
 > - Keep writing code that is relatively readable and adding useful helper methods
 > - Stop using repetitive code with the thought of refactoring later
 > - Stop looking for workarounds and start redoing code to make it cleaner and more logical.